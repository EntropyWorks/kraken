abort "Please run with kraken script from #{File.expand_path(File.join(File.expand_path(File.dirname(__FILE__)), '..', 'kraken'))}" unless defined? VAGRANTFILE_API_VERSION

require 'fog'
require "excon/middleware/aws/exponential_backoff/include"

def create_elb_connection(aws_settings)
  Fog::AWS::ELB.new({
    aws_access_key_id: aws_settings['accessKeyId'],
    aws_secret_access_key: aws_settings['secretAccessKey'],
    region: aws_settings['regionId']
  })
end

# checks for a named ELB
def check_elb(aws_settings)
  connection = create_elb_connection(aws_settings)

  result = connection.describe_load_balancers
  raise "ELB check failed!" unless result.status == 200

  descriptions = result.body['DescribeLoadBalancersResult']['LoadBalancerDescriptions']

  return true if descriptions.select{ |balancer| balancer['LoadBalancerName'] == aws_settings['elb']['name'] }.length > 0
  return false
end

# creates a named ELB
def create_elb(aws_settings)
  return if check_elb(aws_settings)
  connection = create_elb_connection(aws_settings)

  # Build the Load Balancer
  listener_array = aws_settings['elb']['listeners']
  listener_array = [{'elb_port' => 80, 'forwarding_to' => 30061, 'protocol' => 'HTTP'}] if listener_array.nil?

  listeners = listener_array.map do |listener|
    {
      'Protocol' => listener['protocol'],
      'LoadBalancerPort' => listener['elb_port'],
      'InstancePort' => listener['forwarding_to'],
      'InstanceProtocol' => listener['protocol']
    }
  end

  # use first of the forwarded to ports as the healthcheck ping port
  target_port = aws_settings['elb']['heathcheck_port'].nil? ? listeners[0]['InstancePort'] : aws_settings['elb']['heathcheck_port']

  result = connection.create_load_balancer(
    nil,
    aws_settings['elb']['name'],
    listeners,
    {
      :subnet_ids => [ aws_settings['subnetId'] ],
      :security_groups => aws_settings['securityGroupIds']
    }
  )
  raise "ELB creation failed!" unless result.status == 200

  # Let's configure a health check
  health_check_config = {
    "HealthyThreshold" => aws_settings['elb']['healthy_threshold'],
    "Interval" => aws_settings['elb']['interval'],
    "Target" => "TCP:#{target_port}",
    "Timeout" => aws_settings['elb']['timeout'],
    "UnhealthyThreshold" => aws_settings['elb']['unhealthy_threshold']
  }
  health_check_result = connection.configure_health_check(aws_settings['elb']['name'], health_check_config)
  raise "Failed ELB health check configuration request" unless health_check_result.status == 200
end

# destroys a named ELB
def delete_elb(aws_settings)
  return unless check_elb(aws_settings)
  connection = create_elb_connection(aws_settings)

  result = connection.delete_load_balancer(aws_settings['elb']['name'])
  raise "ELB creation failed!" unless result.status == 200
end

def create_elb_dns(aws_settings)
  connection = Fog::DNS.new(
    { 
      :provider => "aws", 
      :aws_access_key_id => aws_settings['accessKeyId'], 
      :aws_secret_access_key => aws_settings['secretAccessKey']
    }
  )
  
  zone = connection.zones.get(aws_settings['hostedZoneId'])
  
  # check if record is present, destroy it if so:
  record = zone.records.get(aws_settings['elb']['dns_name'])
  unless record.nil?
    record.destroy
  end

  # create new record
  record = zone.records.create(
    { 
      :name => aws_settings['elb']['dns_name'], 
      :alias_target => get_elb_dns_info(aws_settings), 
      :type => "A"
    }
  )

  while record.reload.status != "INSYNC"
    sleep 2
  end
end

def get_elb_dns_info(aws_settings)
  alias_target = {}
  connection = create_elb_connection(aws_settings)

  result = connection.describe_load_balancers
  raise "ELB check failed!" unless result.status == 200

  descriptions = result.body['DescribeLoadBalancersResult']['LoadBalancerDescriptions']
  raise "ELB not found" unless descriptions.select{ |balancer| balancer['LoadBalancerName'] == aws_settings['elb']['name'] }.length > 0

  lb_desc = descriptions.select{ |balancer| balancer['LoadBalancerName'] == aws_settings['elb']['name'] }[0]
  
  alias_target['dns_name'] = lb_desc['DNSName']
  alias_target['hosted_zone_id'] = lb_desc['CanonicalHostedZoneNameID']
  alias_target['evaluate_target_health'] = false

  return alias_target
end

def get_instance_type(node_info, aws_settings)
  aws_instance_type = aws_settings['instanceType']
  case node_info[:type]
  when 'master'
    aws_instance_type = aws_settings['instanceTypeMaster'] unless aws_settings['instanceTypeMaster'].nil?
  when 'etcd'
    aws_instance_type = aws_settings['instanceTypeEtcd'] unless aws_settings['instanceTypeEtcd'].nil?
  when 'node'
    aws_instance_type = aws_settings['instanceTypeNode'] unless aws_settings['instanceTypeNode'].nil?

    type_setting = "instanceType_#{node_info[:hostname].gsub('-','_')}"
    aws_instance_type = aws_settings[type_setting] unless aws_settings[type_setting].nil?
  end

  aws_instance_type
end

def get_storage_type(node_info, aws_settings)
  storage_type = aws_settings['instanceStorageType'] || 'ebs'
  case node_info[:type]
  when 'master'
    storage_type = aws_settings['instanceStorageTypeMaster'] unless aws_settings['instanceStorageTypeMaster'].nil?
  when 'etcd'
    storage_type = aws_settings['instanceStorageTypeEtcd'] unless aws_settings['instanceStorageTypeEtcd'].nil?
  when 'node'
    storage_type = aws_settings['instanceStorageTypeNode'] unless aws_settings['instanceStorageTypeNode'].nil?

    storage_setting = "instanceStorageType_#{node_info[:hostname].gsub('-','_')}"
    storage_type = aws_settings[storage_setting] unless aws_settings[storage_setting].nil?
  end

  storage_type
end

def get_ebs_size(node_info, aws_settings)
  ebs_size = aws_settings['instanceEBSSize'] || 300
  case node_info[:type]
  when 'master'
    ebs_size = aws_settings['masterEBSSize'] unless aws_settings['masterEBSSize'].nil?
  when 'etcd'
    ebs_size = aws_settings['etcdEBSSize'] unless aws_settings['etcdEBSSize'].nil?
  when 'node'
    ebs_size = aws_settings['nodeEBSSize'] unless aws_settings['nodeEBSSize'].nil?

    size_setting = "nodeEBSSize_#{node_info[:hostname].gsub('-','_')}"
    ebs_size = aws_settings[size_setting] unless aws_settings[size_setting].nil?
  end

  ebs_size
end

# Find the latest Coreos based on region
aws_settings = cluster_settings['aws']

coreos_ami = {
  "ap-northeest-1" => "coreos_production_ami_hvm_ap-northeast-1.txt",
  "ap-southeast-1" => "coreos_production_ami_hvm_ap-southeast-1.txt",
  "ap-southeast-2" => "coreos_production_ami_hvm_ap-southeast-2.txt",
  "eu-central-1" => "coreos_production_ami_hvm_eu-central-1.txt",
  "eu-west-1" => "coreos_production_ami_hvm_eu-west-1.txt",
  "sa-east-1" => "coreos_production_ami_hvm_sa-east-1.txt",
  "us-east-1" => "coreos_production_ami_hvm_us-east-1.txt",
  "us-gov-west-1" => "coreos_production_ami_hvm_us-gov-west-1.txt",
  "us-west-1" => "coreos_production_ami_hvm_us-west-1.txt",
  "us-west-2" => "coreos_production_ami_hvm_us-west-2.txt"
}

if aws_settings['amiId'] == 'latest'
  aws_ami_url = coreos_ami[aws_settings['regionId']]
  coreos_ami_url = "#{coreos_url}/#{coreos_release}/#{aws_ami_url}"
  aws_settings['amiId'] = open(coreos_ami_url).read().chomp
end

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = File.join(File.expand_path(File.dirname(__FILE__)), 'aws.box')
  config.vm.synced_folder ".", "/vagrant", disabled: true

  # create elb if specified.
  config.trigger.before [:up], :vm => ['master'] do
    info "Creating ELB #{aws_settings['elb']['name']}" unless aws_settings['elb'].nil?
    create_elb(aws_settings) unless aws_settings['elb'].nil?
    create_elb_dns(aws_settings) unless aws_settings['elb'].nil? || aws_settings['elb']['dns_name'].nil? 
  end

  # destroy elb if specified, tie to node 1 to avoid doing this multiple times
  config.trigger.after [:destroy], :vm => ['node-01'] do
    info "Deleting ELB #{aws_settings['elb']['name']}" unless aws_settings['elb'].nil?
    delete_elb(aws_settings) unless aws_settings['elb'].nil?
  end

  (1..(get_num_nodes.to_i + 2)).each do |i|

    tmp_user_data = build_coreos_userdata(i)
    node_info = get_coreos_node_info(i)

    config.vm.boot_timeout = 2
    config.vm.define node_info[:hostname] do |config2|

      config2.vm.provider :aws do |aws, override|

        aws.access_key_id = aws_settings['accessKeyId']
        aws.secret_access_key = aws_settings['secretAccessKey']
        #aws.session_token = ''
        aws.keypair_name = aws_settings['keyPair']
        aws.ami = aws_settings['amiId']
        aws.instance_type = aws_settings['instanceType']
        aws.region = aws_settings['regionId']
        aws.security_groups = aws_settings['securityGroupIds']
        aws.subnet_id = aws_settings['subnetId']
        aws.private_ip_address = base_ip_address + "#{i+100}"
        aws.associate_public_ip = aws_settings['associatePublicIps']
        aws.instance_type = get_instance_type(node_info, aws_settings)

        storage_type = get_storage_type(node_info, aws_settings)

        if storage_type == 'ebs'
          aws.block_device_mapping = [
            { 'DeviceName' => '/dev/sdf', 'Ebs.VolumeSize' => get_ebs_size(node_info, aws_settings) }
          ]
        else
          aws.block_device_mapping = [
            { 'DeviceName' => '/dev/sdb', 'VirtualName' => 'ephemeral0' }
          ]
        end

        case node_info[:type]
        when 'master'
          aws.elastic_ip = aws_settings['masterPublicIp'] if aws_settings['masterPublicIp']
          if aws_settings['masterHostName']
            override.route53.hosted_zone_id = aws_settings['hostedZoneId']
            override.route53.record_set = [dot_record_set(aws_settings['masterHostName']), "A"]
          end
        when 'node'
          if node_info[:hostname] == 'node-01'
            aws.elastic_ip = aws_settings['nodePublicIp'] if aws_settings['nodePublicIp']
            if aws_settings['proxyHostName']
              override.route53.hosted_zone_id = aws_settings['hostedZoneId']
              override.route53.record_set = [dot_record_set(aws_settings['proxyHostName']), "A"]
            end
          end

          # join to ELB if, specified
          aws.elb = aws_settings['elb']['name'] unless aws_settings['elb'].nil?
        end

        aws.user_data = File.read(tmp_user_data)

        instance_name_prefix = aws_settings.fetch('instanceNamePrefix', 'kube')
        aws.tags = {
          'Name' => "#{instance_name_prefix}-" + node_info[:hostname],
          'owner' => Socket.gethostname
        }

        override.ssh.username = "core"
        override.ssh.private_key_path = aws_settings['keyPairPath']
      end

      # Output instructions on how to access the kubernetes cluster from a Mac
      if base_ip_address + "#{i+100}" == final_node_ip
        config.trigger.after [:up] do
          set_kubeconfig("aws")
        end
      end
    end
  end
end
