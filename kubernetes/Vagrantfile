# -*- mode: ruby -*-
# vi: set ft=ruby :

# DO NOT EDIT THIS FILE.
# Use the settings.yaml to modify cluster settings.

require 'fileutils'
require 'tempfile'
require 'net/http'
require 'open-uri'
require 'ipaddr'
require 'yaml'
require 'json'
require 'base64'
require 'mkmf'
require 'fileutils'
require 'erb'
require 'ostruct'

VAGRANTFILE_API_VERSION = "2"
Vagrant.require_version ">= 1.7.2"

# Make the MakeMakefile logger write file output to null.
# Probably requires ruby >= 2.0.0
module MakeMakefile::Logging
  @logfile = File::NULL
end

CLOUDCONFIG_PATH = File.join(__dir__, '..', 'cloud_configs')
SPEC_PATH = File.join(__dir__, '..', 'spec')
CLUSTERS_PATH = ENV.fetch('KRAKEN_CLUSTERS_PATH', File.join(__dir__, 'clusters'))

# fail fast on unspecified or invalid cluster
abort 'KRAKEN_CLUSTER must be defined!' unless ENV.has_key?('KRAKEN_CLUSTER')
CLUSTER_NAME = ENV['KRAKEN_CLUSTER']
CLUSTER_PATH = File.join(CLUSTERS_PATH, CLUSTER_NAME)
abort "#{CLUSTER_NAME} - no such cluster" unless File.directory?(CLUSTER_PATH)

# fail fast if cluster vagrant commands aren't being run through kraken.sh
abort 'VAGRANT_DOTFILE_PATH is not set to the right location.
Make sure to run vagrant commands through kraken.sh' unless ENV['VAGRANT_DOTFILE_PATH'] == CLUSTER_PATH

# all of the externalized settings get loaded here
def cluster_settings
  settings_yaml = File.join(CLUSTER_PATH, 'settings.yaml')
  abort "#{settings_yaml} is not present. Did you create it?" unless File.exist?(settings_yaml)
  YAML.load_file(settings_yaml)
end

def install_plugins
  # for this cluster
  plugins_yaml = File.join(CLUSTER_PATH, 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)

  # plugins required for all clusters
  plugins_yaml = File.join(__dir__, 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)
end

def install_plugins_from_file(plugins_yaml)
  abort "#{plugins_yaml} does not exist" unless File.exist?(plugins_yaml)

  required_plugins = YAML.load_file(plugins_yaml)
  required_plugins['plugins'].each do |plugin|
    need_restart = false
    unless Vagrant.has_plugin? plugin['name'], plugin['version']
      system "vagrant plugin install #{plugin['name']} --plugin-version #{plugin['version']}"
      need_restart = true
    end
    exec "vagrant #{ARGV.join(' ')}" if need_restart
  end
end

def base_ip_address
    settings = cluster_settings
    network = settings['cluster']['network'] || '172.16.1.0/24'

    IPAddr.new(network).to_s.chomp("0")
end

def aws_master
  master = cluster_settings['aws']['masterHostName'] || cluster_settings['aws']['masterPublicIp']
  master
end

def kubernetes_release
  settings = cluster_settings
  version = settings['cluster']['kubernetesVersion'] || 'stable'
  if version == 'stable'
    release_url = "https://storage.googleapis.com/kubernetes-release/release/stable.txt"
    open(release_url).read().gsub('v','').chomp
  else
    version
  end
end

def coreos_channel
  cluster_settings['coreos']['channel'] || 'alpha'
end

def coreos_boxname
  "coreos-#{coreos_channel}"
end

def coreos_url
  "http://#{coreos_channel}.release.core-os.net/amd64-usr"
end

def coreos_release
  settings = cluster_settings
  version = settings['coreos']['version'] || 'latest'
  return version unless version == 'latest'

  version_url = "#{coreos_url}/current/version.txt"
  open(version_url).read().scan(/COREOS_VERSION=.*/)[0].split('=')[1]
end

def final_node_ip
  settings = cluster_settings
  number_of_nodes = settings['cluster']['nodes'] || 2
  base_ip_address + "#{(number_of_nodes + 2 + 100)}"
end

def get_num_nodes
  settings = cluster_settings
  settings['cluster']['nodes'] || 2
end

def cluster_services
  services = cluster_settings['cluster'].fetch('services', {})
  services['repo'] ||= 'git://github.com/samsung-ag/kraken-services'
  services['branch'] ||= 'stable'
  services['dirs'] ||= %w(heapster influxdb-grafana kube-ui loadtest prometheus skydns)
  services
end

def get_coreos_node_info(host_number)
  node_info = Hash.new
  settings = cluster_settings

  case host_number
  when 1
    node_info[:hostname] = 'etcd'
    node_info[:type] = 'etcd'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'etcd.yaml.erb')
    node_info[:memory] = settings['vmSettings']['etcd']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['etcd']['cpus'] || 1 unless settings['vmSettings'].nil?
  when 2
    node_info[:hostname] = 'master'
    node_info[:type] = 'master'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'master.yaml.erb')
    node_info[:memory] = settings['vmSettings']['master']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['master']['cpus'] || 1 unless settings['vmSettings'].nil?
  else
    node_info[:hostname] = "node-%02d" % (host_number - 2)
    node_info[:type] = 'node'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'node.yaml.erb')
    node_info[:memory] = settings['vmSettings']['node']['memory'] || 1024 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['node']['cpus'] || 1 unless settings['vmSettings'].nil?
  end

  node_info
end

def build_coreos_userdata(host_number)
  node_info = get_coreos_node_info(host_number)
  settings = cluster_settings

  etcd_cluster_ip = base_ip_address + "#{1+100}"
  master_cluster_ip = base_ip_address + "#{2+100}"
  proxy_cluster_ip = base_ip_address + "#{3+100}"
  proxy_public_ip = ENV.fetch('NODE_PUBLIC_IP', proxy_cluster_ip)
  if settings.has_key?('aws')
    proxy_public_ip = settings['aws'].fetch('nodePublicIp', settings['aws'].fetch('proxyHostName', proxy_public_ip))
  end

  storage_type = nil
  if CLUSTER_NAME == 'aws'
    aws_settings = settings['aws']
    storage_type = aws_settings['instanceStorageType'] || 'ebs'

    case node_info[:type]
    when 'master'
      storage_type = aws_settings['instanceStorageTypeMaster'] unless aws_settings['instanceStorageTypeMaster'].nil?
    when 'etcd'
      storage_type = aws_settings['instanceStorageTypeEtcd'] unless aws_settings['instanceStorageTypeEtcd'].nil?
    when 'node'
      storage_type = aws_settings['instanceStorageTypeNode'] unless aws_settings['instanceStorageTypeNode'].nil?

      storage_setting = "instanceStorageType_#{node_info[:hostname].gsub('-','_')}"
      storage_type = aws_settings[storage_setting] unless aws_settings[storage_setting].nil?
    end
  end

  render_vars = {
    :etcd_cluster_ip => etcd_cluster_ip,
    :master_cluster_ip => master_cluster_ip,
    :kubernetes_release => 'v' + kubernetes_release,
    :api_version => settings['cluster']['apiVersion'],
    :kubernetes_verbosity => '2',
    :reboot_strategy => settings['coreos']['rebootStrategy'] || 'off',
    :cloud_provider => 'vagrant',
    :dns_domain => 'kubernetes.local',
    :hostname => node_info[:hostname],
    :service_public_ip => proxy_cluster_ip,
    :docker_cache => etcd_cluster_ip,
    :node_01_private_ip => proxy_cluster_ip,
    :node_01_public_ip => proxy_public_ip,
    :final_node_ip => final_node_ip,
    :drive_type => storage_type
  }

  render_vars[:dockercfg_base64] =
    settings['cluster'].fetch('dockercfg_base64',
      settings['cluster'].has_key?('dockercfg') ?
        Base64.strict_encode64(settings['cluster']['dockercfg'].to_json) : '' )

  # logentries values
  enable_logentries = settings['logentries'] != nil and settings['logentries']['enabled']
  logentries_vars = {
    :enable_logentries => enable_logentries,
    :logentries_token => enable_logentries ? settings['logentries']['token'] : nil,
    :logentries_url => enable_logentries ? settings['logentries']['url'] : nil
  }

  kraken_services_vars = {
    :kraken_services_branch => cluster_services['branch'],
    :kraken_services_repo => cluster_services['repo'],
    :kraken_services_dirs => cluster_services['dirs'].join(' ')
  }

  [logentries_vars, kraken_services_vars].each { |vars| render_vars.merge!(vars) }

  tmp_user_data = "/tmp/#{node_info[:hostname]}-vagrantfile-user-data"
  render(
    node_info[:user_data],
    tmp_user_data,
    render_vars
  )

  tmp_user_data
end

def dot_record_set(record_set)
  # Check record for trailing '.' and add one if missing
  if record_set[-1, 1] == '.'
    record_set_dot = record_set
  else
    record_set_dot = record_set.concat('.')
  end

  record_set_dot
end

def set_kubeconfig(cluster)
  # Output the kubectl config settings at the end of the vagrant run
  # kubectl config set-cluster <cluster> --server=http://<master>:8080 --apiVersion=<api_version>
  # Optional: include instructions on create an alias
  #   Run the following command to create a shortcut on a Mac
  #   alias kub<cluster>="kubectl --cluster=local"
  settings = cluster_settings

  master = settings['id'] == 'aws' ? aws_master : base_ip_address + "#{2+100}"
  api_version = settings['cluster']['apiVersion']
  puts "\n\033[34mYou can now access the Kubernetes cluster by creating a new cluster in your kubeconfig by running:\033[0m"
  puts "\033[34mkubectl config set-cluster #{cluster} --server=http://#{master}:8080 --api-version=#{api_version}\033[0m"
  puts "\n\033[34mTalk to the kubernetes cluster by running:\033[0m"
  puts "\033[34mkubectl --cluster=#{cluster} [commands]\033[0m\n\n"
end

def run_tests(config, type)
  config.vm.provision :serverspec do |spec|
    spec.pattern = File.join(SPEC_PATH, "*_#{type}_#{CLUSTER_NAME}_spec.rb")
  end
end

def render(templatepath, destinationpath, variables)
  if File.file?(templatepath)
    template = File.open(templatepath, "rb").read
    content = ERB.new(template).result(OpenStruct.new(variables).instance_eval { binding })
    outputpath = destinationpath.end_with?('/') ? "#{destinationpath}/#{File.basename(templatepath, '.erb')}" : destinationpath
    FileUtils.mkdir_p(File.dirname(outputpath))
    File.open(outputpath, "wb") { |f| f.write(content) }
  end
end

install_plugins

begin
  cluster_vagrantfile = File.join(CLUSTER_PATH, 'Vagrantfile')
  load cluster_vagrantfile
rescue LoadError
  abort "Could not load #{cluster_vagrantfile}"
end
